<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MRO on KK's Blog (fromkk)</title><link>https://www.fromkk.com/tags/mro/</link><description>Recent content in MRO on KK's Blog (fromkk)</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.</copyright><lastBuildDate>Sat, 14 Mar 2020 17:37:00 +0800</lastBuildDate><atom:link href="https://www.fromkk.com/tags/mro/index.xml" rel="self" type="application/rss+xml"/><item><title>C3 Linearization and Python MRO(Method Resolution Order)</title><link>https://www.fromkk.com/posts/c3-linearization-and-python-mro-method-resolution-order/</link><pubDate>Sat, 14 Mar 2020 17:37:00 +0800</pubDate><guid>https://www.fromkk.com/posts/c3-linearization-and-python-mro-method-resolution-order/</guid><description>Python supports multiple inheritance, its class can be derived from more than one base classes. If the specified attribute or methods was not found in current class, how to decide the search sequence from superclasses? In simple scenario, we know left-to right, bottom to up. But when the inheritance hierarchy become complicated, it&amp;rsquo;s not easy to answer by intuition.
For instance, what&amp;rsquo;s search sequence of class M?
class X:pass class Y: pass class Z:pass class A(X,Y):pass class B(Y,Z):pass class M(B,A,Z):pass The answer is: M, B, A, X, Y, Z, object</description></item></channel></rss>