<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Machine Learning on KK's Blog (fromkk)</title><link>https://www.fromkk.com/tags/machine-learning/</link><description>Recent content in Machine Learning on KK's Blog (fromkk)</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.</copyright><lastBuildDate>Wed, 04 Dec 2019 00:16:00 +0800</lastBuildDate><atom:link href="https://www.fromkk.com/tags/machine-learning/index.xml" rel="self" type="application/rss+xml"/><item><title>Near-duplicate with SimHash</title><link>https://www.fromkk.com/posts/near-duplicate-with-simhash/</link><pubDate>Wed, 04 Dec 2019 00:16:00 +0800</pubDate><guid>https://www.fromkk.com/posts/near-duplicate-with-simhash/</guid><description>Before talking about SimHash, let&amp;rsquo;s review some other methods which can also identify duplication.
Longest Common Subsequence(LCS) This is the algorithm used by diff command. It is also edit distance with insertion and deletion as the only two edit operations.
This works good for short strings. However, the algorithm&amp;rsquo;s time complexity is \(O(m*n)\), if two strings&amp;rsquo; lengths are \(m\) and \(n\) respectively. So it&amp;rsquo;s not suitable for large corpus.</description></item><item><title>The Annotated The Annotated Transformer</title><link>https://www.fromkk.com/posts/the-annotated-the-annotated-transformer/</link><pubDate>Sun, 01 Sep 2019 16:00:00 +0800</pubDate><guid>https://www.fromkk.com/posts/the-annotated-the-annotated-transformer/</guid><description>Thanks for the articles I list at the end of this post, I understand how transformers works. These posts are comprehensive, but there are some points that confused me.
First, this is the graph that was referenced by almost all of the post related to Transformer.
Transformer consists of these parts: Input, Encoder*N, Output Input, Decoder*N, Output. I&amp;rsquo;ll explain them step by step.
Input The input word will map to 512 dimension vector.</description></item><item><title>Different Types of Attention</title><link>https://www.fromkk.com/posts/different-types-of-attention/</link><pubDate>Mon, 15 Jul 2019 00:16:00 +0800</pubDate><guid>https://www.fromkk.com/posts/different-types-of-attention/</guid><description>\(s_t\) and \(h_i\) are source hidden states and target hidden state, the shape is (n,1). \(c_t\) is the final context vector, and \(\alpha_{t,s}\) is alignment score.
\[\begin{aligned} c_t&amp;amp;=\sum_{i=1}^n \alpha_{t,s}h_i \\\ \alpha_{t,s}&amp;amp;= \frac{\exp(score(s_t,h_i))}{\sum_{i=1}^n \exp(score(s_t,h_i))} \end{aligned}\]
Global(Soft) VS Local(Hard) Global Attention takes all source hidden states into account, and local attention only use part of the source hidden states.
Content-based VS Location-based Content-based Attention uses both source hidden states and target hidden states, but location-based attention only use source hidden states.</description></item><item><title>Using Dueling DQN to Play Flappy Bird</title><link>https://www.fromkk.com/posts/using-ddqn-to-play-flappy-bird/</link><pubDate>Sun, 14 Apr 2019 17:10:00 +0800</pubDate><guid>https://www.fromkk.com/posts/using-ddqn-to-play-flappy-bird/</guid><description>PyTorch provide a simple DQN implementation to solve the cartpole game. However, the code is incorrect, it diverges after training (It has been discussed here).
The official code&amp;rsquo;s training data is below, it&amp;rsquo;s high score is about 50 and finally diverges.
There are many reason that lead to divergence.
First it use the difference of two frame as input in the tutorial, not only it loss the cart&amp;rsquo;s absolute information(This information is useful, as game will terminate if cart moves too far from centre), but also confused the agent when difference is the same but the state is varied.</description></item><item><title>TextCNN with PyTorch and Torchtext on Colab</title><link>https://www.fromkk.com/posts/textcnn-with-pytorch-and-torchtext-on-colab/</link><pubDate>Mon, 03 Dec 2018 15:47:00 +0800</pubDate><guid>https://www.fromkk.com/posts/textcnn-with-pytorch-and-torchtext-on-colab/</guid><description>PyTorch is a really powerful framework to build the machine learning models. Although some features is missing when compared with TensorFlow (For example, the early stop function, History to draw plot), its code style is more intuitive.
Torchtext is a NLP package which is also made by pytorch team. It provide a way to read text, processing and iterate the texts.
Google Colab is a Jupyter notebook environment host by Google, you can use free GPU and TPU to run your modal.</description></item><item><title>LSTM and GRU</title><link>https://www.fromkk.com/posts/lstm-and-gru/</link><pubDate>Sun, 22 Apr 2018 14:39:00 +0800</pubDate><guid>https://www.fromkk.com/posts/lstm-and-gru/</guid><description>LSTM The avoid the problem of vanishing gradient and exploding gradient in vanilla RNN, LSTM was published, which can remember information for longer periods of time.
Here is the structure of LSTM:
The calculate procedure are:
\[\begin{aligned} f_t&amp;amp;=\sigma(W_f\cdot[h_{t-1},x_t]+b_f)\\\ i_t&amp;amp;=\sigma(W_i\cdot[h_{t-1},x_t]+b_i)\\\ o_t&amp;amp;=\sigma(W_o\cdot[h_{t-1},x_t]+b_o)\\\ \tilde{C_t}&amp;amp;=tanh(W_C\cdot[h_{t-1},x_t]+b_C)\\\ C_t&amp;amp;=f_t\ast C_{t-1}+i_t\ast \tilde{C_t}\\\ h_t&amp;amp;=o_t \ast tanh(C_t) \end{aligned}\]
\(f_t\),\(i_t\),\(o_t\) are forget gate, input gate and output gate respectively. \(\tilde{C_t}\) is the new memory content. \(C_t\) is cell state.</description></item><item><title>Models and Architectures in Word2vec</title><link>https://www.fromkk.com/posts/models-and-architechtures-in-word2vec/</link><pubDate>Fri, 05 Jan 2018 15:14:00 +0800</pubDate><guid>https://www.fromkk.com/posts/models-and-architechtures-in-word2vec/</guid><description>Generally, word2vec is a language model to predict the words probability based on the context. When build the model, it create word embedding for each word, and word embedding is widely used in many NLP tasks.
Models CBOW (Continuous Bag of Words) Use the context to predict the probability of current word. (In the picture, the word is encoded with one-hot encoding, \(W_{V*N}\) is word embedding, and \(W_{V*N}^{&amp;rsquo;}\), the output weight matrix in hidden layer, is same as \(\hat{\upsilon}\) in following equations)</description></item><item><title>Semi-supervised Text Classification Using doc2vec and Label Spreading</title><link>https://www.fromkk.com/posts/semi-supervised-text-classification-using-doc2vec-and-label-spreading/</link><pubDate>Sun, 10 Sep 2017 15:29:00 +0800</pubDate><guid>https://www.fromkk.com/posts/semi-supervised-text-classification-using-doc2vec-and-label-spreading/</guid><description>Here is a simple way to classify text without much human effort and get a impressive performance.
It can be divided into two steps:
Get train data by using keyword classification Generate a more accurate classification model by using doc2vec and label spreading Keyword-based Classification Keyword based classification is a simple but effective method. Extracting the target keyword is a monotonous work. I use this method to automatic extract keyword candidate.</description></item><item><title>Parameters in doc2vec</title><link>https://www.fromkk.com/posts/parameters-in-dov2vec/</link><pubDate>Thu, 03 Aug 2017 15:20:00 +0800</pubDate><guid>https://www.fromkk.com/posts/parameters-in-dov2vec/</guid><description>Here are some parameter in gensim&amp;rsquo;s doc2vec class.
window window is the maximum distance between the predicted word and context words used for prediction within a document. It will look behind and ahead.
In skip-gram model, if the window size is 2, the training samples will be this:(the blue word is the input word)
min_count If the word appears less than this value, it will be skipped</description></item><item><title>Brief Introduction of Label Propagation Algorithm</title><link>https://www.fromkk.com/posts/brief-introduction-of-label-propagation-algorithm/</link><pubDate>Sun, 16 Jul 2017 21:45:00 +0800</pubDate><guid>https://www.fromkk.com/posts/brief-introduction-of-label-propagation-algorithm/</guid><description>As I said before, I&amp;rsquo;m working on a text classification project. I use doc2vec to convert text into vectors, then I use LPA to classify the vectors.
LPA is a simple, effective semi-supervised algorithm. It can use the density of unlabeled data to find a hyperplane to split the data.
Here are the main stop of the algorithm:
Let $ (x_1,y1)&amp;hellip;(x_l,y_l)$ be labeled data, $Y_L = \{y_1&amp;hellip;y_l\} $ are the class labels.</description></item></channel></rss>