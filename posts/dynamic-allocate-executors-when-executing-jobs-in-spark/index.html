<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta http-equiv=content-language content="en">
<meta name=color-scheme content="light dark">
<meta name=author content="KK">
<meta name=description content="I wrote a Spark program to process logs. The number of logs always changes as time goes by. To ensure logs can be processed instantly, the number of executors is calculated by the maximum of logs per minutes. As a consequence, the CPU usage is low in executors. In order to decrease resource waste, I tried to find a way to schedule executors during the execution of program.
As shown below, the maximum number of logs per minutes can be a dozen times greater than the minimum number in one day.">
<meta name=keywords content="fromkk,blog,kk blog,developer,personal,python,golang,go,linux,machine learning">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Dynamic Allocate Executors when Executing Jobs in Spark">
<meta name=twitter:description content="I wrote a Spark program to process logs. The number of logs always changes as time goes by. To ensure logs can be processed instantly, the number of executors is calculated by the maximum of logs per minutes. As a consequence, the CPU usage is low in executors. In order to decrease resource waste, I tried to find a way to schedule executors during the execution of program.
As shown below, the maximum number of logs per minutes can be a dozen times greater than the minimum number in one day.">
<meta property="og:title" content="Dynamic Allocate Executors when Executing Jobs in Spark">
<meta property="og:description" content="I wrote a Spark program to process logs. The number of logs always changes as time goes by. To ensure logs can be processed instantly, the number of executors is calculated by the maximum of logs per minutes. As a consequence, the CPU usage is low in executors. In order to decrease resource waste, I tried to find a way to schedule executors during the execution of program.
As shown below, the maximum number of logs per minutes can be a dozen times greater than the minimum number in one day.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.fromkk.com/posts/dynamic-allocate-executors-when-executing-jobs-in-spark/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-07-18T16:52:00+08:00">
<meta property="article:modified_time" content="2022-01-15T14:25:28+08:00">
<title>
Dynamic Allocate Executors when Executing Jobs in Spark · KK's Blog (fromkk)
</title>
<link rel=canonical href=https://www.fromkk.com/posts/dynamic-allocate-executors-when-executing-jobs-in-spark/>
<link rel=preload href="https://www.fromkk.com/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin>
<link rel=stylesheet href=https://www.fromkk.com/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css integrity="sha256-2f3b/+byfmmYXcX+BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin=anonymous media=screen>
<link rel=stylesheet href=https://www.fromkk.com/css/coder-dark.min.002ee2378e14c7a68f1f0a53d9694ed252090987c4e768023fac694a4fc5f793.css integrity="sha256-AC7iN44Ux6aPHwpT2WlO0lIJCYfE52gCP6xpSk/F95M=" crossorigin=anonymous media=screen>
<link rel=icon type=image/png href=https://www.fromkk.com/icons/icon-32x32.png sizes=32x32>
<link rel=icon type=image/png href=https://www.fromkk.com/icons/icon-16x16.png sizes=16x16>
<link rel=apple-touch-icon href=https://www.fromkk.com/icons/icon-192x192.png>
<link rel=apple-touch-icon sizes=180x180 href=https://www.fromkk.com/icons/icon-192x192.png>
<meta name=generator content="Hugo 0.92.2">
</head>
<body class="preload-transitions colorscheme-auto">
<div class=float-container>
<a id=dark-mode-toggle class=colorscheme-toggle>
<i class="fa fa-adjust fa-fw" aria-hidden=true></i>
</a>
</div>
<main class=wrapper>
<nav class=navigation>
<section class=container>
<a class=navigation-title href=https://www.fromkk.com/>
KK's Blog (fromkk)
</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle>
<i class="fa fa-bars fa-fw" aria-hidden=true></i>
</label>
<ul class=navigation-list>
<li class=navigation-item>
<a class=navigation-link href=https://www.fromkk.com/posts/>Blog</a>
</li>
<li class=navigation-item>
<a class=navigation-link href=https://www.fromkk.com/tags/>Tags</a>
</li>
<li class=navigation-item>
<a class=navigation-link href=https://www.fromkk.com/about/>About</a>
</li>
<li class=navigation-item>
<a class=navigation-link href=https://www.fromkk.com/posts/index.xml>RSS</a>
</li>
</ul>
</section>
</nav>
<div class=content>
<section class="container post">
<article>
<header>
<div class=post-title>
<h1 class=title>
<a class=title-link href=https://www.fromkk.com/posts/dynamic-allocate-executors-when-executing-jobs-in-spark/>
Dynamic Allocate Executors when Executing Jobs in Spark
</a>
</h1>
</div>
<div class=post-meta>
<div class=date>
<span class=posted-on>
<i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2021-07-18T16:52:00+08:00>
07/18/2021
</time>
</span>
<span class=reading-time>
<i class="fa fa-clock-o" aria-hidden=true></i>
4-minute read
</span>
</div>
<div class=tags>
<i class="fa fa-tag" aria-hidden=true></i>
<span class=tag>
<a href=https://www.fromkk.com/tags/spark/>Spark</a>
</span></div>
</div>
</header>
<div>
<p>I wrote a Spark program to process logs. The number of logs always changes as time goes by. To ensure logs can be processed instantly, the number of executors is calculated by the maximum of logs per minutes. As a consequence, the CPU usage is low in executors. In order to decrease resource waste, I tried to find a way to schedule executors during the execution of program.</p>
<p>As shown below, the maximum number of logs per minutes can be a dozen times greater than the minimum number in one day.</p>
<figure><img src=https://www.fromkk.com/images/dynamic_log_number.png>
</figure>
<p>If I can modify the executor number by size of data to proceed, the resource usage should increase.</p>
<h2 id=dynamic-allocation>
Dynamic Allocation
<a class=heading-link href=#dynamic-allocation>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2>
<p>Spark provide a similar configuration to control the number of executors. By enable <code>spark.dynamicAllocation.enabled</code>, spark will change number of running executors by task number automatically.</p>
<h3 id=how-does-dynamic-allocation-work>
How does Dynamic Allocation Work?
<a class=heading-link href=#how-does-dynamic-allocation-work>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3>
<h4 id=request-executors>
Request Executors
<a class=heading-link href=#request-executors>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4>
<p>As is known to all, the action operators(such as <code>count</code>, <code>collect</code>) create Spark job. Each job is divided into stages by shuffle operation, and each data partition in the stage will become independent jobs. When dynamic allocation is enabled, if there have been pending tasks for <code>spark.dynamicAllocation.schedulerBacklogTimeout</code> seconds, driver will request for more executors. If the pending task still exists, the executor request will be triggered every <code>spark.dynamicAllocation.sustainedSchedulerBacklogTimeou</code> seconds. Furthermore, the number of executors requested in each round increases exponentially from the previous round. For instance, an application will add 1 executor in the first round, and then 2, 4, 8 and so on executors in the subsequent rounds. The number of total running executor should not exceed <code>spark.dynamicAllocation.maxExecutors</code>.</p>
<p>When receiving the first executor request, driver ask cluster manager to create executor. After the new executor is created, driver checks if there are more request waiting to created and handle all of the pending request.</p>
<p>The reason to use this strategy to create executor is to avoid creating too many executor when payload just peak for a short time and make sure there are enough executor to be created in a period of time if the payload keeps high.</p>
<h4 id=release-executors>
Release Executors
<a class=heading-link href=#release-executors>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4>
<p>After the executor is idle for <code>spark.dynamicAllocation.executorIdleTimeout</code> seconds, it will be released. The one which contains cache data will not be removed. To prevent the executor which keeps the shuffle data from being removed, a additional spark service is needed before spark 3.0. From 3.0, the external shuffle service is not required if <code>spark.dynamicAllocation.shuffleTracking.enabled</code> is used.</p>
<p>Dynamic allocation is easy to used, but there are two disadvantage:</p>
<ol>
<li>Slow scheduling. Creating executors is serial. If two or more executor is requested, driver will ask cluster manager to create executors for at least two times. This is an issue if pods creation takes time. In general, that is fine as the K8s 1.6 SLO is that 99% of pods should be created in 5s in a 5000 node cluster.</li>
<li>Hard to release executor if each task is short. The release is based on the idle time. If there are so many short task, the executor is not like to idle as tasks are assigned uniformly.</li>
</ol>
<p>In our spark program, the task is short and data must be processed in 1 minutes. So dynamic allocation not suitable.</p>
<h2 id=manual-allocation>
Manual Allocation
<a class=heading-link href=#manual-allocation>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2>
<p>Luckily, spark also provide a way to control the number of executors manually. We can use <code>sc.requestExecutors</code> and <code>sc.killExecutors</code> to create and delete executors.</p>
<p>In order to use these two function, we have to know the number of running executors and their IDs.</p>
<p><strong>Number of Running Executors</strong></p>
<p>The Spark program&rsquo;s RAM usage can be obtained from <code>sc.getExecutorMemoryStatus</code>. It returns a dict list like this: <code>[Map(10.73.3.67:59136 -> (2101975449,2101612350))]</code>. The key is IP with port and value is a tuple contains the max RAM and available RAM. Please note that driver is also included in the return data.</p>
<p><strong>IDs of Running Executors</strong></p>
<p>IDs is required when calling <code>sc.killExecutors</code>. This can be found in <a href=https://spark.apache.org/docs/latest/monitoring.html#rest-api>Spark REST API</a>. The executors information such as ID, cores and tasks is record in <code>/applications/[app-id]/executors</code>.</p>
<p>With the help of <code>sc.requestExecutors</code>, we can create as many executors as we want in one request. But the pod create time is still too long. To eliminate the pod create request, I used these strategies:</p>
<ol>
<li>The running executors is expected to finish job in 50s, fot the purpose of reversing some time for delayed tasks.</li>
<li>When the expected executor is close to current running executors, no executor is requests or released.</li>
<li>If there is backlog data, request more executors.</li>
</ol>
<h2 id=result>
Result
<a class=heading-link href=#result>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2>
<p>After using manually allocation, the CPU usage grows a lot and reaches 40%. The cores used by Spark programs drop from 1700 to 800. Furthermore, the Spark program can scale automatically.</p>
<figure><img src=https://www.fromkk.com/images/dymanic_cpu_before.png>
</figure>
<figure><img src=https://www.fromkk.com/images/dymanic_cpu_after.png>
</figure>
</div>
<footer>
<script src=https://utteranc.es/client.js repo=bebound/bebound.github.io issue-term=pathname label=comment theme=preferred-color-scheme crossorigin=anonymous async></script>
</footer>
</article>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload="renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:!0},{left:'$',right:'$',display:!1},{left:'\\(',right:'\\)',display:!1},{left:'\\[',right:'\\]',display:!0}]})"></script>
</section>
</div>
<footer class=footer>
<section class=container>
©
2022
KK
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.
</section>
</footer>
</main>
<script src=https://www.fromkk.com/js/coder.min.39a51230dce2ac866c049b52573e38bf60666af4bc63c1bdf203b9b2d95b1cd6.js integrity="sha256-OaUSMNzirIZsBJtSVz44v2BmavS8Y8G98gO5stlbHNY="></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-153788833-1','auto'),ga('send','pageview'))</script>
</body>
</html>