<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta http-equiv=content-language content="en">
<meta name=color-scheme content="light dark">
<meta name=author content="KK">
<meta name=description content="It&rsquo;s easy to get small dataset from Elasticsearch by using size and from. However, it&rsquo;s impossible to retrieve large dataset in the same way.
Deep Paging Problem    As we know it, Elasticsearch data is organised into indexes, which is a logical namespace, and the real data is stored into physical shards. Each shard is an instance of Lucene. There are two kind of shards, primary shards and replica shards.">
<meta name=keywords content="fromkk,blog,kk blog,developer,personal,python,golang,go,linux,machine learning">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Retrieve Large Dataset in Elasticsearch">
<meta name=twitter:description content="It&rsquo;s easy to get small dataset from Elasticsearch by using size and from. However, it&rsquo;s impossible to retrieve large dataset in the same way.
Deep Paging Problem    As we know it, Elasticsearch data is organised into indexes, which is a logical namespace, and the real data is stored into physical shards. Each shard is an instance of Lucene. There are two kind of shards, primary shards and replica shards.">
<meta property="og:title" content="Retrieve Large Dataset in Elasticsearch">
<meta property="og:description" content="It&rsquo;s easy to get small dataset from Elasticsearch by using size and from. However, it&rsquo;s impossible to retrieve large dataset in the same way.
Deep Paging Problem    As we know it, Elasticsearch data is organised into indexes, which is a logical namespace, and the real data is stored into physical shards. Each shard is an instance of Lucene. There are two kind of shards, primary shards and replica shards.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.fromkk.com/posts/retrieve-large-dataset-in-elasticsearch/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-06-21T20:33:00+08:00">
<meta property="article:modified_time" content="2020-06-21T20:33:15+08:00">
<title>
Retrieve Large Dataset in Elasticsearch · KK's Blog (fromkk)
</title>
<link rel=canonical href=https://www.fromkk.com/posts/retrieve-large-dataset-in-elasticsearch/>
<link rel=preload href="https://www.fromkk.com/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin>
<link rel=stylesheet href=https://www.fromkk.com/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css integrity="sha256-2f3b/+byfmmYXcX+BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin=anonymous media=screen>
<link rel=stylesheet href=https://www.fromkk.com/css/coder-dark.min.002ee2378e14c7a68f1f0a53d9694ed252090987c4e768023fac694a4fc5f793.css integrity="sha256-AC7iN44Ux6aPHwpT2WlO0lIJCYfE52gCP6xpSk/F95M=" crossorigin=anonymous media=screen>
<link rel=icon type=image/png href=https://www.fromkk.com/icons/icon-32x32.png sizes=32x32>
<link rel=icon type=image/png href=https://www.fromkk.com/icons/icon-16x16.png sizes=16x16>
<link rel=apple-touch-icon href=https://www.fromkk.com/icons/icon-192x192.png>
<link rel=apple-touch-icon sizes=180x180 href=https://www.fromkk.com/icons/icon-192x192.png>
<meta name=generator content="Hugo 0.92.1">
</head>
<body class="preload-transitions colorscheme-auto">
<div class=float-container>
<a id=dark-mode-toggle class=colorscheme-toggle>
<i class="fa fa-adjust fa-fw" aria-hidden=true></i>
</a>
</div>
<main class=wrapper>
<nav class=navigation>
<section class=container>
<a class=navigation-title href=https://www.fromkk.com/>
KK's Blog (fromkk)
</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle>
<i class="fa fa-bars fa-fw" aria-hidden=true></i>
</label>
<ul class=navigation-list>
<li class=navigation-item>
<a class=navigation-link href=https://www.fromkk.com/posts/>Blog</a>
</li>
<li class=navigation-item>
<a class=navigation-link href=https://www.fromkk.com/tags/>Tags</a>
</li>
<li class=navigation-item>
<a class=navigation-link href=https://www.fromkk.com/about/>About</a>
</li>
<li class=navigation-item>
<a class=navigation-link href=https://www.fromkk.com/posts/index.xml>RSS</a>
</li>
</ul>
</section>
</nav>
<div class=content>
<section class="container post">
<article>
<header>
<div class=post-title>
<h1 class=title>
<a class=title-link href=https://www.fromkk.com/posts/retrieve-large-dataset-in-elasticsearch/>
Retrieve Large Dataset in Elasticsearch
</a>
</h1>
</div>
<div class=post-meta>
<div class=date>
<span class=posted-on>
<i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2020-06-21T20:33:00+08:00>
06/21/2020
</time>
</span>
<span class=reading-time>
<i class="fa fa-clock-o" aria-hidden=true></i>
5-minute read
</span>
</div>
<div class=tags>
<i class="fa fa-tag" aria-hidden=true></i>
<span class=tag>
<a href=https://www.fromkk.com/tags/elasticsearch/>Elasticsearch</a>
</span></div>
</div>
</header>
<div>
<p>It&rsquo;s easy to get small dataset from Elasticsearch by using <code>size</code> and <code>from</code>. However, it&rsquo;s impossible to retrieve large dataset in the same way.</p>
<h2 id=deep-paging-problem>
Deep Paging Problem
<a class=heading-link href=#deep-paging-problem>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2>
<p>As we know it, Elasticsearch data is organised into indexes, which is a logical namespace, and the real data is stored into physical shards. Each shard is an instance of Lucene. There are two kind of shards, primary shards and replica shards. Replica shards is the copy of primary shards in case nodes or shards fail. By distributing documents in an index across multiple shards, and distributing those shards across multiple nodes, Elasticsearch can ensure redundancy and scalability. By default, Elasticsearch create <strong>5</strong> primary shards and one replica shard for each primary shards.</p>
<figure><img src=https://www.fromkk.com/images/elasticsearch_cluster.png width=600>
</figure>
<p>How to decide which shard should the document be distributed? By default, <code>shard = hashCode(doc._id) % primary_shards_number</code>. To make this stable, the number of primary shards cannot be change the index has been created.</p>
<p>Usually, the shards size should be 20GB to 40GB. The number of shards a node can hold is depending on the heap space. In general, 1GB heap space can hold 20 shards.</p>
<p>As data is store in different shards. If there are 5 shards, when doing this query:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>GET /_search?size=10
</code></pre></div><p>Each shards will generate 10 search result, and send results to coordinate node. The coordinate node will sort 50 items, and result the first 10 result to user. However when query become this:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>GET /_search?size=10&amp;from=10000
</code></pre></div><p>Although we only need 10 items, each shards has to return the first 10010 result to coordinate node, and coordinate node has to sort 50050 items, this search cost lots of resource.</p>
<p>As deep paging is costly, Elasticsearch has restrict <code>from+size</code> less than <code>index.max-result-window</code>, the default value is <code>10000</code>.</p>
<h2 id=scroll>
Scroll
<a class=heading-link href=#scroll>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2>
<p>The <code>search</code> method has to retrieve and sort the result over and over again, because it does not know how to continue the search from previous position.</p>
<p><code>scroll</code> is more efficient when retrieve large set of data.</p>
<p>For example:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>POST /twitter/_search?scroll=1m
{
    &#34;size&#34;: 100,
    &#34;query&#34;: {
        &#34;match&#34; : {
            &#34;title&#34; : &#34;elasticsearch&#34;
        }
    }
}
</code></pre></div><p>and the returned result will contains a <code>_scroll_id</code>, which should be passed to the <code>scroll</code> API in order to retrieve the rest of data.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>POST /_search/scroll
{
    &#34;scroll&#34; : &#34;1m&#34;,
    &#34;scroll_id&#34; : &#34;DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==&#34;
}
</code></pre></div><p><code>Scroll</code> return the matched result at the time of the initial search request, like a snapshot, and ignore the subsequent changes to the documents(index, update or delete). The <code>scroll=1m</code> is used to tell how long should Elasticsearch keep the context. If there no following requests using the returned <code>scroll_id</code>, the scroll context will expire.</p>
<p>PS: In fact, when dealing the initial search request, <code>scoll</code> will cache all the matched documents' id, then get the <code>size</code> document content in batches for each following requests.</p>
<h3 id=slice>
Slice
<a class=heading-link href=#slice>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3>
<p>It&rsquo;s also possible to split the scroll in multiple slices and consume them independently.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>GET /twitter/_search?scroll=1m
{
    &#34;slice&#34;: {
        &#34;id&#34;: 0,
        &#34;max&#34;: 2
    },
    &#34;query&#34;: {
        &#34;match&#34; : {
            &#34;title&#34; : &#34;elasticsearch&#34;
        }
    }
}
GET /twitter/_search?scroll=1m
{
    &#34;slice&#34;: {
        &#34;id&#34;: 1,
        &#34;max&#34;: 2
    },
    &#34;query&#34;: {
        &#34;match&#34; : {
            &#34;title&#34; : &#34;elasticsearch&#34;
        }
    }
}
</code></pre></div><p>The above request contains split the slice into <code>2</code> parts by using <code>max:2</code> parameter. These union of two requests' data is equivalent to the result of a scroll query without slicing.</p>
<p>The slice of the document can be calculated by this formula: <code>slice(doc) = hash(doc._id) % max_slice</code>. This is quiet similar to the calculation of shards mentioned before. For example if slice is 4, and shards is 2. Then slices <code>0,2</code> are assigned to first shard and slices <code>1,3</code> are assigned to second shard.</p>
<p>When slices number is <code>n</code>, each matched documents use a <code>n</code> bitset to remember which slice it belongs to. So you should limit the number of sliced query you perform in parallel to avoid the memory explosion.</p>
<p>Getting <code>hash(doc._id)</code> is expensive. You can also use another numeric <code>doc_value</code> field to do the slicing without hash function. For instance:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>GET /twitter/_search?scroll=1m
{
    &#34;slice&#34;: {
        &#34;field&#34;: &#34;date&#34;,
        &#34;id&#34;: 0,
        &#34;max&#34;: 10
    },
    &#34;query&#34;: {
        &#34;match&#34; : {
            &#34;title&#34; : &#34;elasticsearch&#34;
        }
    }
}
</code></pre></div><blockquote>
<p>Query performance is most efficient when the number of slices is equal to the number of shards in the index. If that number is large (e.g. 500), choose a lower number as too many slices will hurt performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.</p>
<p>from <a href=https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html#docs-reindex-automatic-slice>Picking the number of slices</a></p>
</blockquote>
<h2 id=search-after>
Search After
<a class=heading-link href=#search-after>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2>
<p>Scroll is not suitable for real-time user requests. After Elasticsearch 5, <code>Search After</code> API is added. It&rsquo;s similar to scroll but provides a live cursor. It uses the results from the previous page to retrieve the next page.</p>
<p>To use search after, the query must be sorted, and the following query also contains <code>search_after=previous sort value</code>.</p>
<p>For example, if the initial query is this:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>GET twitter/_search
{
    &#34;size&#34;: 10,
    &#34;query&#34;: {
        &#34;match&#34; : {
            &#34;title&#34; : &#34;elasticsearch&#34;
        }
    },
    &#34;sort&#34;: [
        {&#34;date&#34;: &#34;asc&#34;},
        {&#34;tie_breaker_id&#34;: &#34;asc&#34;}
    ]
}
</code></pre></div><p>Then you have to extract the sort value of the last document, and pass it to <code>search_after</code> to get the next page result.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>GET twitter/_search
{
    &#34;size&#34;: 10,
    &#34;query&#34;: {
        &#34;match&#34; : {
            &#34;title&#34; : &#34;elasticsearch&#34;
        }
    },
    &#34;search_after&#34;: [1463538857, &#34;654323&#34;],
    &#34;sort&#34;: [
        {&#34;date&#34;: &#34;asc&#34;},
        {&#34;tie_breaker_id&#34;: &#34;asc&#34;}
    ]
}
</code></pre></div><h2 id=ref>
Ref
<a class=heading-link href=#ref>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2>
<ol>
<li><a href=https://www.elastic.co/guide/en/elasticsearch/guide/current/pagination.html>Elasticsearch: The Definitive Guide: Pagination</a></li>
<li><a href=https://www.elastic.co/guide/en/elasticsearch/reference/current/scalability.html>Scalability and resilience: clusters, nodes, and shards</a></li>
<li><a href=http://arganzheng.life/deep-pagination-in-elasticsearch.html>ElasticSearch如何支持深度分页</a></li>
<li><a href=https://discuss.elastic.co/t/documentation-for-scroll-api-is-a-bit-confusing/185954>Documentation for scroll API is a bit confusing!</a></li>
<li><a href=https://www.elastic.co/guide/en/elasticsearch/reference/6.3/search-request-scroll.html>Request Body Search: Scroll</a></li>
<li><a href=https://qbox.io/blog/optimizing-elasticsearch-how-many-shards-per-index>Optimizing Elasticsearch: How Many Shards per Index?</a></li>
</ol>
</div>
<footer>
<script src=https://utteranc.es/client.js repo=bebound/bebound.github.io issue-term=pathname label=comment theme=preferred-color-scheme crossorigin=anonymous async></script>
</footer>
</article>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload="renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:!0},{left:'$',right:'$',display:!1},{left:'\\(',right:'\\)',display:!1},{left:'\\[',right:'\\]',display:!0}]})"></script>
</section>
</div>
<footer class=footer>
<section class=container>
©
2022
KK
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.
</section>
</footer>
</main>
<script src=https://www.fromkk.com/js/coder.min.39a51230dce2ac866c049b52573e38bf60666af4bc63c1bdf203b9b2d95b1cd6.js integrity="sha256-OaUSMNzirIZsBJtSVz44v2BmavS8Y8G98gO5stlbHNY="></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-153788833-1','auto'),ga('send','pageview'))</script>
</body>
</html>